0 Doku
    X Doku anpassen: ColSum
        X PDF korrigieren
        X Flowgraph anpassen
            X FLipTrans muss an anderen Stellen gemacht werden
    X Doku anpassen:
        X Änderungen
            X b2 ist jetzt cbc
            X score ist initial cbc
            X so kann die operation scalarsubix schnell ausgeführt werden
            X dann wird flip ausgeführt
        X Algo anpassen
        X Flowchart anpassen
1 Mat CPU - 31h
    1.1
        - TB für CPU Mul
            X Alle Tests aus mat_mul übernehmen
            X Einen Test ergänzen, für korrekte Spaltenweise Speicherung
                X Bei Spaltenweiser Speicherung sollen eigentlich nur einzelne Element gesetzt werden, es wird aber immer ein gesamtes word gesetzt
                X Evtl ix_gen anpassen, so dass die mat_c spaltenweise statt zeilenweise berechnet wird
    1.2 - 4h
        X TB für CPU Add
            X Entsprechende Tests
            X Desktruktive Variante (a=c)
            X Spaltenweise Addition
            X Spaltenweise Speicherung

        1.2.1
            X Eventuelle Fehler korrigieren
                X ix gen anpassen für spaltenweise speicherung
                X set word elem anpassen
    1.3 - 4h
        - TB für Trans
            X Zeilenweise
            X Spaltenweise
    1.4 - 2h
        - Restliche TBs
            X MatDel 
            X ScalarMul
            X ScalarDiv
            X ScalarMax
            X Desktruktive Variante (a=c)
            X Zeilenweise
            X Spaltenweise
    1.5 - 2h
        - Parallel TB
            X Parallele Verarbeitung von 3 Kommandos
            - Weitere Tests
    1.6 - 1h
        - Master TB
            X Alle einzel-TBs zusammen kopiert
    1.7 - 10h
        - Restliche Operationen
            X FlipTrans 2h
            X VecAdd - 2h
            X ColSum - 4h
            X ScalarSubIx - 4h
    1.8 8h 
        - TB
            X FlipTrans 2h
            x Test für ColSum Spaltenweise speicherung
            X VecAdd - 2h
            X ColSum - 3h
            X ScalarSubIx - 3h
    
    1.9 3 OpCores
        X 0: MatMul, MatAdd, VecAdd, RowSum, NoOp
        X 1: ScalarMul, ScalarDiv, ScalarMax, ScalarSubIx, NoOp 
        X 2: MatTrans, MatFlip, MatDel, NoOp

    1.10 
        X Matrizenvergleich beschleunigen
    1.11 
        . ScalarSubIx korrigieren: Nur Ein bestimmtes Element verringern
            ( Es muss in jeder Zeile ein anderes Element verringert weerden)
        - Matrix Löschen beschleunigen
        - 2. AMtAdd hinzüfügen (zu OpCore 2) => 2 Parallele Additionen
     
2 Reconf Algo - 30h
    2.1 -1h
        X Algorithmus zur Parallelen Verarbeitung anpassen

    2.1 2h
        - Entity entwerfen 
        - Kommandos: Start_Algo, Load_image, ...

    2.2 3h
        Zustandsautomat entwerfen

    2.3 8h
        ALle Schritte des Algo implementieren

    2.4 16h
        Testbench für einen einzelnen Batch

3 TLE 36h
    3.1 
        X Serielle Kommunikation
    3.2 16h
        Zustandsautomat für Seriellen Protokoll
            - Init
            - 64 mal
                - Bild empfangen und mit Algo speichern
                - Klasse empfangen, in Algo speichern
            - Algorithmus starten
            - Byte senden um nächsten Batch zu starten
    3.3 4h
        - Kommando hinzufügen, um Algorithmus Training zu beenden
        - Und Ausgabe der Fehlerraten

    3.4 16h
        Testbench: Bilder von HDD laden, Algo ausführen

4 Testen 16h

----------------------------------------------------------------------------------------------------------------------------------------------------

Insgesamt benötigt: 113h

Verfügbar:
    - KW28: 20h
    - KW31: 8
    - KW32: 20
    - KW33: 20
    - KW34: 40
=> 108h Also ende August lauffähig

Ende KW28:
    - Alle TBs für bereits implementierte OP
    - Alle weiteren OP implementiert

Ende KW31:
    - TBs für ALLE operatoren
    - Mat CPU Master TB
    - Struktur des Reconf Algo

Ende KW31:
    - Testbench Reconf algo

Ende KW31:
    - Design TLE
    - Protokoll

Ende KW31:
    - Testbench für TLE
    - HW GEsamt Test



----------------------------------------------------------------------------------------------------------------------------------------------------
Ergebnisse Gespräch Timm
    X ALU
        X Statt 1 Finished Flag alle 3 Rausgeben
    X MEGAMUX
        X statt den Standardwerten am Anfang der Prozesse Dont Cares verwenden
    - Reconf-Algo
        - Kein Zustandsautomat
        - Stattdessen opcodes, reg_ixs, usw in Array Speichern
        - Program Counter um Array zu indizieren
    - Serial Port
        - Senden
            - Schieberegister mit Daten, Start und Stoppbit
            - rausschieben mit bestimmter Geschwindigkeit
        - Empfangen
            - auf fallende Flanke warten
            - dann 1/2 bit warten, so dass in der mitte abgetastet wird
            - dann bit abtasten, also 1x schieberegister schieben
            - dann 1 bit warten
            - nächstes bit abtatsten...
        - Zum Puffern der Daten: Megawizard FiFo Block verwenden
        - Alternativ: 2 Mat Register in die abwechselnd rein geschrieben wird
            - Es muss garantiert sein dass der Algo rechtzeitg fertig wird
        - Kritisch: Uart wird 97% der Rechenzeit belegen, dann werden sich unsere Programme kaum unterscheiden

    X Test-Matrizen
        X Daten in Array Speichern und durchiterieren

    - Taktanalyse
        - *.sdc Datei Erstellen => Grobe Abschätzung durch Compiler
        - Genauer Analyse: TimeQuest Timing Analyzer Wizard
            - Im 1. Tab
                - Taktrate einstellen: 50MHz
                - Dann sagt er ob er es mit 50Mhz schafft
                    - Wenn nicht muss ich Registerstufen einführen
                - Er sagt auch ob er es schneller schafft. Das ist aber nicht unbedingt die Maximale Taktrate
            - Der gibt auch Reports raus, aus denen kann man sich dann die eigentliche max. Taktrate berechnen
        - Anderes Device einstellen
            - Und nochmal den TimeQuest Timing Analyzer Wizard durchlaufen lassen, ob es z.b. mit 300 MHz klappt

    - Kenngrößen fpr Doku:
        - Max Taktrate 
            - Taktrate die der Algo benötigt, bis er fertig ist
        - Platzbedarf des Designs
        - Benötigte RAM-Blöcke
        - Verwendete Multiplizierer
        - Besserer FPGA
            - Schnellere Taktrate
            - Mehr Parallelität möglich



- Modified Delete: Delete only used words in matrix
- Add 2nd Adder to OpCore 2